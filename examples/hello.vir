union type State {
    Idle(Word[4], Word[1]);
    SpinCW(Word[5], Word[4]);
    SpinCCW(Word[5], Word[4]);
}

mod Edge {
    incoming clock : Clock;
    incoming inp   : Word[1];
    outgoing out   : Word[1];

    reg last : Word[1] on clock;
    last <= inp;

    out := last->not()->and(inp);
}

pub mod Top {
    incoming clock : Clock;
    outgoing led_0 : Word[1];
    outgoing led_1 : Word[1];
    outgoing led_2 : Word[1];
    outgoing led_3 : Word[1];
    outgoing led_4 : Word[1];

    reg counter : Word[32] on clock;
    counter <= counter->inc();

    mod edge_detector of Edge;
    edge_detector.clock := clock;
    edge_detector.inp   := counter[17];

    reg state : State on clock;
    state <= if edge_detector.out {
        match state {
            @Idle(round, next) => if round->lt(3) {
                @Idle(round->inc(), next)
            } else {
                if next {
                    @SpinCCW(0b10000, 0)
                } else {
                    @SpinCW(0b00001, 0)
                }
            };
            @SpinCW(x, round) => if x->eq(0b10000) {
                if round->lt(8) {
                    @SpinCW(0b00001, round->inc())
                } else {
                    @Idle(0, 1)
                }
            } else {
                @SpinCW(x->sll(1), round)
            };
            @SpinCCW(x, round) => if x->eq(0b00001) {
                if round->lt(8) {
                    @SpinCCW(0b10000, round->inc())
                } else {
                    @Idle(0, 0)
                }
            } else {
                @SpinCCW(x->srl(1), round)
            };
        }
    } else {
        state
    };


    node led : Word[5];
    led := match state {
        @Idle(round, next) => 0;
        @SpinCW(leds, round) => leds;
        @SpinCCW(leds, round) => leds;
    };

    led_0 := led[0];
    led_1 := led[1];
    led_2 := led[2];
    led_3 := led[3];
    led_4 := led[4];
}


/*
mod Resetter {
    incoming clock   : Clock;
    outgoing reset : Word[1];

    reg counter : Word[8] on clock;
    counter <= if counter->gt(0) {
        counter->sub(1)
    } else {
        0
    };

    reset := counter->eq(1);
}
*/

/*
    node foo : State;
    foo := @Running(0w2, 15);

    reg counter : Word[32] on clock;
    counter <= counter->inc();

    node led : Word[5];
    led :=
        let is_fpga : Word[1] = 1 in
        if is_fpga {
            counter[25..20]
        } else {
            counter[29..24]
        };

    led_0 := led[0];
    led_1 := led[1];
    led_4 := led[2];
    led_2 := led[3];
    led_3 := led[4];
}


mod Buffer {
    incoming clock : Clock;
    incoming inp : Word[3];
    outgoing out : Word[3];

    reg buffer : Word[3] on clock;
    buffer <= inp;
    out := buffer;
}
*/
