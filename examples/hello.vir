alt type State {
    Idle();
    Running(Word[3]);
}

pub mod Top {
    incoming clock : Clock;
    outgoing led_0 : Word[1];
    outgoing led_1 : Word[1];
    outgoing led_2 : Word[1];
    outgoing led_3 : Word[1];
    outgoing led_4 : Word[1];

    reg counter : Word[32] on clock;
    counter <= counter->inc();

    reg state : State on clock;
    state <= if counter[22] {
        match state {
            @Idle() => @Running(0);
            @Running(x) => if x->eq(7) {
                @Idle()
            } else {
                @Running(x->inc())
            };
        }
    } else {
        state
    };


    node led : Word[5];
    led := match state {
        @Idle() => 0;
        @Running(x) => if x->lt(3) {
            counter[27..22]
        } else {
            counter[27..22]->and(0b10101)
        };
    };

    led_0 := led[0];
    led_1 := led[1];
    led_2 := led[2];
    led_3 := led[3];
    led_4 := led[4];
}

/*
mod Resetter {
    incoming clock   : Clock;
    outgoing reset : Word[1];

    reg counter : Word[8] on clock;
    counter <= if counter->gt(0) {
        counter->sub(1)
    } else {
        0
    };

    reset := counter->eq(1);
}
*/

/*
    node foo : State;
    foo := @Running(0w2, 15);

    reg counter : Word[32] on clock;
    counter <= counter->inc();

    node led : Word[5];
    led :=
        let is_fpga : Word[1] = 1 in
        if is_fpga {
            counter[25..20]
        } else {
            counter[29..24]
        };

    led_0 := led[0];
    led_1 := led[1];
    led_4 := led[2];
    led_2 := led[3];
    led_3 := led[4];
}


mod Buffer {
    incoming clock : Clock;
    incoming inp : Word[3];
    outgoing out : Word[3];

    reg buffer : Word[3] on clock;
    buffer <= inp;
    out := buffer;
}
*/
