use crate::*;
use crate::ast::*;

grammar;

pub Package: Package = {
    <defs: Def*> => Package(defs),
}

Def: Def = {
    <m:ModDef> => Def::ModDef(m),
}

Visibility: Visibility = {
  <v:"public"?> => {
    if v.is_none() {
      Visibility::Private
    } else {
      Visibility::Public
    }
  }
}

ModDef: ModDef = {
    <v:Visibility> "module" <name:Id> "{"
        <decls:(Decl ";")*>
    "}" => {
        let mut components = vec![];
        let mut connect = vec![];
        let mut submodules = vec![];

        for (decl, _semi) in decls {
          match decl {
            Decl::Component(c) => components.push(c),
            Decl::Connect(c) => connect.push(c),
            Decl::Submodule(m) => submodules.push(m),
          }
        }

        ModDef {
            name,
            components,
            connect,
            submodules,
        }
    }
}

Decl: Decl = {
    <c:Component> => Decl::Component(c),
    <c:Connect> => Decl::Connect(c),
    <m:Submodule> => Decl::Submodule(m),
}

Component: Component = {
    "incoming" <id:Id> ":" <typ:Type> => {
        Component::Incoming(id, *typ)
    },
    "outgoing" <id:Id> ":" <typ:Type><connect:(":=" Expr)?> => {
        let val = connect.map(|s| *s.1); // .1 ignores the ":=" token
        Component::Outgoing(id, *typ, val)
    },
    "wire" <id:Id> ":" <typ:Type><connect:(":=" Expr)?> => {
        let val = connect.map(|s| *s.1); // .1 ignores the ":=" token
        Component::Wire(id, *typ, val)
    },
    "reg" <id:Id> ":" <typ:Type> "on" <clk:Expr> <reset:("reset" Expr)?> <connect:("<=" Expr)?> => {
        let rst = reset.map(|s| *s.1); // .1 ignores the "reset" keyword
        let set = connect.map(|s| *s.1); // .1 ignores the "<=" token
        Component::Reg(id, *typ, *clk, rst, set)
    },
}

Connect: Connect = {
    <target:Path> ":=" <e:Expr> => Connect(target, ConnectType::Continuous, *e),
    <target:Path> "<=" <e:Expr> => Connect(target, ConnectType::Latched, *e),
    <target:Path> "$=" <e:Expr> => Connect(target, ConnectType::Control, *e),
}

Submodule: Submodule = {
    "submodule" <name:Id> "of" <moddef:Id> => Submodule(moddef, name),
}

Type: Box<Type> = {
  "Clock" => Box::new(Type::Clock),
  "Word" "[" <w:Nat> "]" => Box::new(Type::Word(w)),
}

pub Expr: Box<Expr> = {
//    <e:ExprLet> => e,
//    <e:ExprIf> => e,
//    <e:ExprMatch> => e,
    <e:ExprCall> => e,
}

ExprCall: Box<Expr> = {
//    <ll:@L> <name:Ctor> <rr:@R> =>  Box::new(Expr::Call(name, vec![], vec![])),
//    <ll:@L> <name:Ctor> "(" <es:ExprList> ")" <rr:@R> =>  Box::new(Expr::Call(name, vec![], es)),
    "cat" "(" <es:ExprList> ")" => {
        Box::new(Expr::Cat(es))
    },
    <ll:@L> <name:Id> "(" <es:ExprList> ")" <rr:@R> => {
        Box::new(Expr::FnCall(name, es))
    },
    <ll:@L> <s:ExprIdx> "->" <name:Id> "(" <es:ExprList> ")" <rr:@R> => {
        Box::new(Expr::MethodCall(Type::Unknown, s, name, es))
    },
    <e:ExprIdx> => e,
}

ExprIdx: Box<Expr> = {
    <ll:@L> <e:ExprIdx> "->" <field:Id> <rr:@R> => Box::new(Expr::IdxField(e, field.clone())),
    <ll:@L> <e:ExprIdx> "[" <i:Nat> "]" <rr:@R> => Box::new(Expr::Idx(e, i)),
    <ll:@L> <e:ExprIdx> "[" <j:Nat> ".." <i:Nat> "]" <rr:@R> => Box::new(Expr::IdxRange(e, j, i)),
    <e:ExprBase> => e,
}

ExprBase: Box<Expr> = {
    <e:ExprVec> => e,
    <e:ExprStruct> => e,
    <e:ExprWith> => e,
//    <e:ExprAs> => e,
    <e:ExprLit> => e,
    <e:ExprReference> => e,
    "(" <e:Expr> ")" => e,
}

ExprStruct: Box<Expr> = {
    <ll:@L> "struct" <name:Id> "{" <fields:FieldExprList> "}" <rr:@R> => {
        let fields = fields.iter().map(|(name, e)| (name.to_string(), Box::new(e.clone()))).collect();
        Box::new(Expr::Struct(Type::Unknown, fields))
    },
}

FieldExprList: Vec<(String, Expr)> = {
    <fields:((Id "=" Expr ("," Id "=" Expr)* ","?)?)> => {
        if let Some((name, _eqsign, expr, fields, _comma)) = fields {
            let mut results = vec![(name.to_string(), *expr)];
            for (_comma, name, _eqsign, expr) in fields {
                results.push((name.to_string(), *expr));
            }
            results
        } else {
            vec![]
        }
    },
}

/*
ExprAs: Box<Expr> = {
  "as" <t:Type> "("
}
*/

ExprWith: Box<Expr> = {
  "with" <e:Expr> "{"
    <edits:ExprWidthEdit*>
  "}" => {
    Box::new(Expr::With(e, edits))
  }
}

ExprWidthEdit: WithEdit = {
  "this" "[" <n:Nat> "]" "=" <e:Expr> ";" => WithEdit::Idx(n, e),
  "this" "->" <id:Id> "]" "=" <e:Expr> ";" => WithEdit::Field(id, e),
}

ExprVec: Box<Expr> = {
    <ll:@L> "[" <es:ExprList> "]" <rr:@R> => Box::new(Expr::Vec(Type::Unknown, es)),
    <ll:@L> "[" <e:Expr> ";" <n:Nat> "]" <rr:@R> => Box::new(Expr::Vec(Type::Unknown, vec![*e; n as usize])),
}

ExprList: Vec<Expr> = {
    <exprs:((Expr ("," Expr)* ","?)?)> => {
        if let Some((expr, exprs, _comma)) = exprs {
            let mut results = vec![*expr];
            for (_comma, expr) in exprs {
                results.push(*expr);
            }
            results
        } else {
            vec![]
        }
    },
}

ExprLit: Box<Expr> = {
    <ll:@L> <lit:WordLit> <rr:@R> => {
        Box::new(Expr::Word(lit.width(), lit.val()))
    },

    "true" => Box::new(Expr::Bool(true)),
    "false" => Box::new(Expr::Bool(false)),
}

ExprReference: Box<Expr> = {
  <path: Path> => Box::new(Expr::Reference(Type::Unknown, path))
}


Path: Path = {
    <id0:Id> <ids:("." Id)*> => {
        let mut parts = vec![id0];
        for (_, id) in ids {
          parts.push(id);
        }
        let path: String = parts.join(".").chars().collect();
        path.into()
    },
}

WordLit: WordLit = {
    <n:Nat> => WordLit(None, n),
    <lit:r"[0-9][_0-9]*w[0-9]+"> => {
        let lit_nounders: String = lit.chars().filter(|&c| c != '_').collect();
        let parts = lit_nounders.split("w").collect::<Vec<_>>();
        let v = parts[0].parse().unwrap();
        let width = parts[1].parse().unwrap();
        WordLit(Some(width), v)
    },
    <lit:r"0b[0-1][_0-1]*w[0-9]+"> => {
        let lit_nounders: String = lit.chars().filter(|&c| c != '_').collect();
        let parts = lit_nounders.split("w").collect::<Vec<_>>();
        let v = u64::from_str_radix(&parts[0][2..], 2).unwrap();
        let width = parts[1].parse().unwrap();
        WordLit(Some(width), v)
    },
    <lit:r"0x[0-9a-fA-F][_0-9a-fA-F]*w[0-9]+"> => {
        let lit_nounders: String = lit.chars().filter(|&c| c != '_').collect();
        let parts = lit_nounders.split("w").collect::<Vec<_>>();
        let v = u64::from_str_radix(&parts[0][2..], 16).unwrap();
        let width = parts[1].parse().unwrap();
        WordLit(Some(width), v)
    },
}

Nat: u64 = {
    <lit:r"[0-9][_0-9]*"> => {
        let lit_nounders: String = lit.chars().filter(|&c| c != '_').collect();
        lit_nounders.parse().unwrap()
    },
    <lit:r"0b[0-9][_0-9]*"> => {
        let lit_nounders: String = lit.chars().filter(|&c| c != '_').collect();
        u64::from_str_radix(&lit_nounders[2..], 2).unwrap()
    },
    <lit:r"0x[0-9][_0-9]*"> => {
        let lit_nounders: String = lit.chars().filter(|&c| c != '_').collect();
        u64::from_str_radix(&lit_nounders[2..], 16).unwrap()
    },
}

Id: Ident = {
    <ll:@L> <id:r"[_A-Za-z][_A-Za-z0-9]*"> <rr:@R> => {
        id.to_string()
    },
}

match {
    r"//[^\n\r]*[\r\n]" => {},
    r"[\r\n]*" => {},
    r"/\*[^*]*\*/" => {},
    r" " => {},
    _,
}
